%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt, a4paper, oneside]{article}

\input{packages.tex}
\input{macros.tex}

\title{Side Channel Attack}
\author{
    Leonardo Costa Santos\\
    Lucas Paiolla Forastiere\\
    Julia Leite
}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Introdução}

\par \textit{Side Channel Attacks}, que do inglês significa Ataques por Canal
Lateral, são jeitos explorar vunerabilidades físicas de componentes eletrônicos,
como a CPU de um computador, através de mecanismos físicos alheios à lógica do
componente.

O nome vem do fato de ser uma técnica que não ataca ``pela porta da frente'',
mas sim algum ``rastro'' físico que um componente deixa ao fazer determinadas
ações. Como a energia gasta pelos transistores de uma CPU ao fazer uma soma.

Um SCA não necessariamente tem a ver com componentes eletrônicos, pois podemos,
por exemplo, descifrar uma senha de alguém captando os sons do teclado. Em
geral, o SCA ataca um ponto fraco de um componente que não tem nada a ver com o
seu funcionamento em si (como no exemplo do teclado, o teclado teoricamente não
tem a responsabilidade de deixar os barulhos de cada tecla idênticos). Daí
então o nome \textit{canal lateral}.

Para dar outro exemplo, suponha que uma pessoa está escrevendo em um papel com
uma caneta e se deseja saber o que está escrito (uma senha, por exemplo). O modo
mais direto é olhar para o papel escrito e ler o conteúdo, mas imagine que essa
possibilidade não existe porque a pessoa está de costas para você. Suponha então
que se cria um programa que, dado um vídeo de uma pessoa de costas escrevendo em
um papel, consegue decifrar o que está escrito usando os movimentos do braço
direito da pessoa. Isso seria um exemplo de ataque por canal lateral. Outros
ataques, entretanto, são possíveis. Pode-se gravar o som e usá-lo para
descifrar, ou então usar uma câmera que grava imagens em frequências de luz não
visível. As possibilidades são vastas.

Trazendo para o mundo do computador e dos algoritmos, Daniel Genkin, cientista
da computação na Universidade de Michigan e líder em pesquisas em \textit{side
channel attacks}, dá uma ótima explicação do que são eles ao dizer que geralmente
quando se desenvolve um algoritmo, se pensa nas entradas e saídas e não em o que
acontece quando o programa é executado. O problema é que computadores não são
executados em papeis, mas sim em física, diz ele.~\cite{andy2020whatisanSCA}

Recentemente, dois SCAs trouxeram fama para o ramo ao revelar que praticamente
qualquer computador pessoal moderno está sujeito a tais vulnerabilidades,
independentemente do Sistema Operacional utilizado. São eles o \textit{Meltdown}
e o \textit{Spectre}, descobertos independentemente por uma série de
pesquisadores, destacando-se o grupo \textit{Project Zero} da
Google.~\cite{Lipp2018meltdown}

Existem muitas classes de SCA, como ataques ao cache (que é o caso dos dois
exemplos citados), ataques que monitoram a energia consumida pelo
computador, ataques que monitoram o eletromagnetismo eminido, ataques que
monitoram o som emitido (como o exemplo do teclado), ataques que recuperam dados
excluidos do disco, entre muitos outros. Esta monografia se propõe como uma
introdução ao assunto, explicando os diferentes tipos de ataques e
exemplificando alguns deles mais a fundo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{História} % julia

\par Um dos mais notórios ataques análogo ao que hoje conhecemos como ataque por canais laterais, foi chamado
pela \textit{National Security Agency} (NSA) de Tempest~\cite{tempestNSA, historyWired}
e ocorreu em 1943, quando pesquisadores do \textit{Bell Lab}
descobriram que, utilizando um osciloscópio, era possível recuperar $75\%$ do texto de uma mensagem
emitida por um \textit{teletype machine} há 80 pés (aproximadamente 24.3 metros) de distância.

\par Entretanto, o termo \textit{Side Channel Cryptanalysis} surgiu
apenas em 1998, em um artigo~\cite{historyPaper} onde criptógrafos
da \textit{Counterpane Systems} e pesquisadores da \textit{University of California
at Berkeley} descreveram como ataques por canais laterais podem ser usados para
quebrar sistemas de criptografia.

\par Em 2014, pesquisadores da \textit{Tel Aviv University}~\cite{RatioTelAviv}
desenvolveram um dispositivo capaz de descobrir senhas criptografadas
de laptop's próximos monitorando sua emissão elétrica. Além disso, em agosto do mesmo
ano, esse grupo de pesquisadores publicou um artigo mostrando que o padrão
sons, detectável por um microfone, emitidos por um computador durante o processo de descriptografia varia de acordo com a chave RSA utilizada, apesar disso,
não ficou claro como extrair os bits da chave RSA.~\cite{historyMic}

\par Desde 2018, o termo \textit{side channel attack} se popularizou
graças à descoberta de vunerabilidades presentes na maioria dos
processadores Intel fabricados nas últimas duas décadas, exploradas
por SCA como \textit{Meltdown}, \textit{Spectre}, entre outros.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Classificações de Side Channel Attacks} % lucas

Na classificação mais clássica de \textit{Side Channel Attacks}, temos que eles podem ser
classificados quanto a duas categorias:~\cite{Spreitzer2018classification,
Standaert2010introduction, Hutle2015resilience}

\begin{enumerate}
    \item Invasivo \textit{vs.} não-invasivo: Ataques invasivos são aqueles que
abrem o aparelho atacado. Um exemplo disso é conectar um cabo a um barramento
do computador para ver os dados transferidos por aquele barramento.  Os ataques
invasivos por sua vez podem ser subdividos em \textbf{completamente invasivos}
ou \textbf{parcialmente invasivos}. Os parcialmente invasivos são aqueles que
deixam o componente intacto após o ataque, enquanto os completamente invasivos
são aqueles que danificam o componente para que o ataque possa ser realizado.
    \item Ativo \textit{vs.} passivo: Os ataques passivos são aqueles que se
restringem a observar os comportamentos de um dispositivo para realizar o
ataque, enquanto os ativos são aqueles que manipulam o dispositivo para que
possam obter as informações desejadas. Eles podem fazer isso, por exemplo,
injetando vários tipos de falhas elétricas, óticas, etc.
\end{enumerate}

Além dessas classificações, pode-se classificar os \textit{side channel attacks}
em classes diferentes. Entre elas há:

\begin{itemize}
    \item \textbf{Ataques de tempo:} São o tipo de ataque mais clássico. Eles se
baseam na diferença de tempo na execução de algoritmos dependendo do dado. Por
exemplo, considere um algoritmo que verifica se uma senha está correta.
    \begin{lstlisting}[language=c]
    bool check_password(char *passwd) {
        for (int i = 0; i  < pass_len; i++)
            if (passwd[i] != stored_passwd[i])
                return false;
        return true;
    }
    \end{lstlisting}
Observa-se que o algoritmo devolve falso assim que descobre um caracter que não
bate com o da senha e retorna verdadeiro caso todos os caracteres estejam
corretos. Ou seja, caso se tente uma senha na qual o primeiro caracter esteja
correto, o algoritmo \texttt{check\_password} levará um pouco mais de tempo do
que no caso em que o primeiro caracter esteja errado. Ao analisar, portanto, o
tempo de retorno, obtem-se um método eficiente de descobrir qual é a senha
desejada.~\cite{Hutle2015resilience}

    \item \textbf{Ataques de análise de gasto energético:} Nesse tipo de ataque,
o canal lateral observado é o gasto energético do dispositivo. Como as
instruções são enviadas e executadas por cadeias de transistores, é possível
obter um padrão característico de cada instrução.

Esses ataques são divididos em \textbf{simples} e \textbf{diferenciais}. O
simples envolve uma análise manual significativa e ele pode ser evitado gerando
gastos aleatórios de energia (por exemplo, inserindo ciclos extras que não fazem
nada colaborativo). No diferencial, entretanto, o atacante mede os gastos
energéticos várias vezes e depois cria um modelo de gasto teórico de energia de
um algoritmo com um pequeno número de bits chutados. Depois disso, o
atacante cria modelos estatísticos para dizer quão perto os chutes estão das
respostas corretas. Devido ao alto número de medições e métodos estatísticos
poderosos, essa abordágem pode conseguir resultados mesmo se medidas de proteção
forem tomadas.~\cite{Hutle2015resilience}

    \item \textbf{Ataques eletromagnéticos:} Esses ataques se aproveitam de
sinais eletromagnéticos que um dispositivo acaba emitindo. Um exemplo clássico
foram os ataques \textit{TEMPEST}, um dos primeiros tipos de \textit{Side
Channel Attacks} a serem estudados. Eles também podem ser divididos em
\textbf{simples} e \textbf{diferenciais}, pois também se pode utilizar os mesmos
métodos estatísticos que se utilizam nos ataques de análise de gasto
energético.~\cite{Hutle2015resilience}

\item \textbf{Ataques acústicos:} Eles se aproveitam de barulhos emitidos pelo
computador para extrair informações importantes.

Um exemplo bastante interessante é ouvir o barulho das teclas do teclado e
deduzir quais foram as teclas pressionadas. Ainda em 2004, quando
\textit{Machine Learning} e Redes Neurais não eram um tema em alta, um grupo de
pesquisadores da IBM postou um artigo mostrando que Redes Neurais poderiam ser
treinadas para reconhecer o que foi teclado com base apenas no som captado por
um microfone.~\cite{Asonov2004KeyboardAE}

Outro exemplo de ataque acústico é aquele que explora os pequenos sons emitidos
por um computador devido ao estresse mecânico causado pelo calor. Esses sons
podem ser captados e utilizados junto com alguma análise estatística para gerar
informação.~\cite{Shamir2013acousticrsa}

    \item \textbf{Ataques óticos:} Utilizando câmeras de alta resolução
apontadas para partes específicas do computador é possível extrair informações
de quais instruções o computador está executando. Por exemplo, podemos usar uma
câmera infravermelha apontada para o processador e fazer um mapa de calor.

    \item \textbf{Ataques de dados remanecente:} Esses ataques conseguem ler
dados mesmo depois de terem sido deletados. Muitas vezes, quando deletamos um
arquivo utilizando uma chamada para o sistema, a única mudança realizada por
muitos Sistemas Operacionais é marcar aquelas posições de memória do disco como
livres, para que outros dados possam sobrescrevê-las no futuro. Isso abre,
portanto, uma brecha para que se possa recuparar os dados supostamente
deletados.

Outro exemplo é o chamado \textit{cold boot attack}, em que um atacante com
acesso físico ao computador performa um \textit{dump} da memória RAM ao dar um
\textit{hard reset} da máquina. Ao contrário do que se pensa, a memória volátil
não perde todos os dados assim que cortamos a energia do computador. Na verdade,
alguns dados podem ficar até noventa minutos na memória após o computador ser
desligado. Consequentemente, um atacante pode performar o chamado \textit{cold
boot}, ligando a máquina através de um sistema operacional especial
pré-instalado em um USB, CD-ROM ou pela rede para que esses dados possam ser
recuperados e utilizados pelo atacante para encontrar informação
sensível.~\cite{Halderman2009coldboot, Bali2018coldbootcellphones,
privateCore2013CBvideo}

    \item \textbf{Ataques de análise de falha:} Esse tipo de ataque introduz
falhas propositalmente em mecanismos para revelar como eles funcionam
internamente. Um chip de cartão de crédito, por exemplo, pode ser exposto a
altas temperaturas ou voltagens, a campos eletromagnéticos forte ou até mesmo a
radiação para influenciar o processador na tentativa de deduzir quais são as
instruções em execução.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Exemplos de Side Channel Attacks}

\subsection{Meltdown} % lucas

Meltdown é um SCA relacionado ao processador e a um efeito colateral da execução
\textit{fora-de-ordem} feita por ele. Graças a ela, o \textit{Meltdown} consegue
quebrar a hierarquia entre o \textit{espaço do usuário} e o \textit{espaço do
núcleo}, podendo ler informações que não deveriam ser acessíveis por qualquer
usuário, como senhas e dados pessoais.

Atualmente, o principal mecanismo de defesa de qualquer sistema operacional é a
\textit{isolação da memória}, dividindo a memória principal entre os diversos
processos em andamento de forma que as regiões de memória em uso por um não
possam ser acessadas por outros.

Para conseguir isso e outras propriedades importantes do Sistema Operacional,
ele se utiliza da chamada \textit{memória virtual}, que é uma abstração para a
memória física. Essa memória virtual é divide em páginas de memória que podem
ser individualmente mapeadas em regiões da memória física através de uma
\textit{tabela de tradução de páginas}.

Essa tabela não só tem como função mapear as páginas de memória, mas também
dividi-las entre as páginas que pertecem ao usuário e às que pertencem ao núcleo
(e daí surgem os termos \textit{espaço do usuário} e \textit{espaço do núcleo}).

Através da tabela, o SO garante que o usuário não conseguirá acessar espaços de
acesso restrito ao núcleo. Entretanto, o núcleo pode e deve ter acesso a toda a
memória física em si (inclusive a parte em que se mapeam as páginas de usuário).
Isso significa na prática que dentro da memória virtual do núcleo, existe uma
região que mapea toda a memória física, permitindo que o núcleo altere posições
de memória do usuário quando ele faz chamadas ao sistema.

\begin{figure}[h]
\centering
\includegraphics[scale=0.9]{Res/virtual_memory_mapping.png}
\caption{A memória física é completamente mapeada pelo núcleo em um certo ponto
da sua memória virtual. Os endreços físicos (em azul) são mapeados pelo usuário,
mas também pelo núcleo, sendo acessível pelos dois com eficiência.}
\label{virtual_memory_mapping}
\end{figure}

Além disso, outro mecanismo crucial de defesa é a separação entre o
\textit{espaço do usuário} e o \textit{espaço do núcleo}, ou seja, uma divisão
entre quais processos (e quais partes da memória) pertencem a processos do
usuário e quais pertencem ao sistema operacional em si.

Essa divisão é tipicamente realizada por um bit supervisor do processador que
define se uma página de memória do núcleo pode ou não ser acessada. E a ideia
por trás desse bit é que ele será mudado para $1$ quando um processo precisa
fazer chamadas ao sistemas (\textit{syscalls}), portanto parando de executar
código do usuário e passando a executar código do núcleo, e mudado novamente
para $0$ quando saímos do modo núcleo.

Esse bit é utilizado com uma ideia de eficiência, pois permite que o SO mapeie o
núcleo no espaço de endereço do processo que fez a \textit{syscall}.
Consequentemente, não há nenhuma mudança no mapeamento da memória quando mudamos
do modo usuário para o modo núcleo (o que é crucial para garantir mais
velocidade).

O \textit{Meltdown} explora uma vunerabilidade causa pela \textit{execução
fora-de-ordem} para ler dados mapeados no espaço de endereço do núcleo, o que
inclui a memória física inteira em sistemas Linux, Android e OS X e uma grande
parte da memória física em ambientes Windows.

As CPUs modernas possuem essa técnica de otimização chamada de \textit{execução
fora-de-ordem} que permite que os núcleos passem mais tempo trabalhando (menos
tempo ocioso), mesmo quando uma determinada operação precisa esperar algum
recurso (por exemplo, trazer um valor da memória). Basicamente, o que acontece é
que ao invés de a CPU executar as instruções sequenciamente, ela vai as
executando assim que todos os recursos necessários para uma determinada
instrução estiverem disponíveis.

Na prática, isso significa que a CPU \textit{especula} que uma determina
instrução será executada no futuro e, então, faz a sua execução antes mesmo de
ter certeza disso. O desenvolvedor do algoritmo que possibilitou a
\textit{execução fora-de-ordem} foi Tomasulo em
1967~\cite{Tomasulo1967outoforder}.

A vunerabilidade encontrada pelo \textit{Meltdown} se deve ao fato de que ao
tentar executar uma instrução de acessar uma região de memória que não pertence
ao programa, a \textit{execução fora-de-ordem} acabará fazendo o acesso e
armazenando o valor no \textit{cache}. Apenas depois que esse dado é armazenado
no \textit{cache}, a CPU percebe que a instrução não deveria ser executada e não
de fato entrega esse valor ao programa que solicitou. Contudo, como o dado está
em cache, o programa pode fazer um \textit{ataque ao cache} para recuperar essa
informação, acessando, portanto, uma região da memória que não pertence ao
programa atacante.

Todo processor Intel feito desde 1995 (exceto o \textit{Intel Itanium} e
\textit{Intel Atom}) implementa \textit{execuções fora-de-ordem} e, portanto,
está suscetível. Além disso, é bastante difícil de detectar se um computador
está sendo explorado pelo \textit{Meltdown}, pois ele é um ataque a nível de
CPU. Entretanto, nunca se teve notícias de computadores infectados, o que
significa que, embora possível, o ataque é bastante difícil de se implementar na
prática. Ademais, existem atualizações para Linux, Windows e OS X contra o
\textit{Meltdown}.

\subsection{Spectre} % leo
\textit{Spectre} é uma classe de ataques que explora execução fora de ordem para
vazar dados dos buffer microarquiteturais, sendo capaz de escolher as instruções
que serão executadas e utilizá-las como um canal secreto para vazar os dados da
memória do processo alvo.

A primeira variante do \textit{Spectre} ataca a predição de \emph{branches}
condicionais, treinando o preditor para executar a \emph{branch} errada.
Ele faz isso executando uma condição com entradas válidas várias vezes, e
então a executando com uma entrada inválida. Assim, o preditor fará com que o
processador execute a \emph{branch} errada especulativamente. Se esta
\emph{branch} faz um acesso à um endereço de memória do processo alvo, os dados
desse endereço serão carregados no \emph{cache}, podendo ser acessados por um
ataque ao \emph{cache}.

A segunda variante ataca a predição de \emph{branches} indiretas, que busca
prever o alvo uma instrução que acessa um endereço calculado em tempo de
execução. O processo do atacante tenta acessar repetidamente o endereço de um
\emph{gadget} (i.e.\ um trecho de código qualquer na memória que seja útil
para o ataque) no espaço de endereços do processo alvo, ou um endereço que é
mapeado à mesma linha de cache. Assim, quando o processo alvo alcançar essa
\emph{branch} indireta, o endereço que o atacante escolheu será executado
ou acessado especulativamente. Isso permite que o atacante execute trechos de
código arbitrários do processo alvo, incluindo código de bibliotecas
compartilhadas, e/ou ler dados de endereços arbitrários.~\cite{Kocher2018spectre}

% explicar return oriented programming ?
Assim, o ataque funciona como um ataque de \emph{Return Oriented Programming},
porém sem a necessidade de vulnerabilidades no processo alvo.

\subsection{CacheOut} % leo
CacheOut é um ataque de \emph{Microarchitectural Data Sampling} (MDS), ou
Amostragem de Dados Microarquitetural, capaz de evitar as medidas de segurança
contra MDSs dos processadores da Intel. Este ataque é capaz de vazar dados
atravéz de barreiras de segurança como o isolamento de mémoria entre processos,
entre \emph{user/kernel spaces}, \emph{SGX enclaves} e máquinas virtuais.
Ao causar contenção de linhas de cache, \textit{CacheOut} causa a expulsão de
dados do cache e lê estes dados dos LFBs com um ataque TAA, conseguindo vazar
páginas inteiras de memória.~\cite{schaik2020cacheout}

\subsubsection{Line Fill Buffers}
\emph{Line Fill Buffers} (LFBs) são \emph{buffers} microarquiteturais usados
para armazenar dados durante acessos ao cache L1, tratando de pedidos ao
cache em \emph{cache misses} e temporariamente armazenando dados em acessos
à memória e operações de I/O. Também podem ser usados em \emph{cache hits}
e para encaminhar dados para operações de leitura e escrita no
\emph{cache}.~\cite{IntelMDS}

\subsubsection{Transactional Synchronization Extensions}
\emph{Transactional Synchronization Extensions} (TSX) é uma implementação de
transações de memória, que agrupa instruções em transacões executadas de modo
atômico, executando todas as instruções da transação especulativamente e
consolidando os resultados apenas após a execução de sua última instrução. Se
alguma instrução causa uma \emph{memory fault}, a transação inteira é
descartada.~\cite{schaik2020cacheout}

\subsubsection{TSX Asynchronous Abort}
\emph{TSX Asynchronous Abort} (TAA) é um tipo de ataque que zera linhas de cache
antes de uma transação que carrega dados dessas linhas, causando uma falha
na transação. Alocando espaço no LFB antes da transação, os dados do LFB são
encaminhados para a instrução que causa a \emph{fault}. Como a transação não
é completada, a instrução é executada com dados de uma transação anterior,
permitindo a amostragem desses dados.~\cite{schaik2020cacheout}

\subsection{ZombieLoad} % julia

\par Em 14 de maio de 2019 um grupo formado por pesquisadores de diversas
universidades, dentre elas a austríaca \textit{Graz University of Technology} e
a belga \textit{Catholic University of Leuven}, e por equipes da segurança
Oracle, Cyberus, entre outras, juntamente com a Intel, reportou uma novo tipo de
SCA, nomeado \textit{ZombieLoad}~\cite{Schwarz2019ZombieLoad}, que explora
vulnerabilidades presentes na maioria dos processadores Intel fabricados após
2011.~\cite{zombieWired}

\par O \textit{ZombieLoad}, assim com o \textit{Spectre}, \textit{Meltdown},
\textit{Foreshadow}, entre outros, pertence à classe dos
\textit{transient-execution attacks}~\cite{canella2019systematic}, ataques que
exploram vulnerabilidades resultantes de técnicas utilizadas para melhorar a
performance do computador, como a execução fora de ordem e a execução
especulativa. A primeira é um  paradigma que permite que a CPU, ao invés de
executar as microoperações de um conjunto de instruções sequencialmente,
execute-as em paralelo, mesmo que a microoperação anterior não tenha sido
finalizada, e as reorganize depois, decidindo aproveitar ou descartar os
resultados. Já a segunda  consiste na CPU executar instruções especulativamente,
ou seja, antes delas aparecerem na lista de instruções, utilizando análise do
fluxo de dados e predicção de desvio, assim como na técnica anterior, os
resultados das instruções executadas especulativamente podem ser aproveitados ou
descartados.

\par Nesse caso, chamamos essa instrução executada fora de ordem ou
especulativamente, cujo resultado foi descartado de \textit{transient
instruction}. Os efeitos da \textit{transient execution} são descartados,
contudo, utilizando canais laterais como o \textit{CPU cache subsystem},
é possível extrair dados de outros processos carregados no
mesmo core da CPU, como senhas, tokens, histórico de navegação do
browser, entre outros.

\par A Intel liberou correções em microcódigo para os processadores
vulneráveis e a 8ª e 9ª geração de processadores possuem correção em
hardware. Contudo, essas mitigações reduzem a velocidade do computador
em $3\%$ e a potência em $9\%$. Os pesquisadores, no entanto, afirmam
que essas medidas são insuficientes para evitar que um computador
esteja vulnerável a esse ataque e que a solução mais segura seria
desabilitar o \textit{hyperthreading}.~\cite{cyberus}


\subsection{Foreshadow} % julia

Em 2015, a Intel incluiu um reforço de segurança nos processadores Intel x86,
O \textit{Software Guard eXtentions} (SGX). SGX é um conjunto de códigos de
instruções relacionadas a segurança que permite ao usuário e ao sistema
operacional definir regiões privadas da memória, com isolamento reforçado por
hardware, chamadas enclaves, cujo conteúdo não pode ser lido ou salvo por
qualquer processo fora do próprio enclave.~\cite{IntelSGX}.

Em 2018, contudo, um novo SCA, chamado de \textit{Foreshadow} pelos cientistas
que descobriram, rompeu com a convicção sobre a segurança do SGX. Esse ataque,
denominado \textit{L1 Terminal Fault} (L1TF) pela Intel, explora uma
vulnerabilidade na execução especulativa, a mesma explorada pelo
\textit{Meltdown}, permitindo ao atacante extrair segredos do enclave enquanto
estão no cache L1 sem fazer suposições sobre o código enclave da vítima e sem
precisar de acesso ao \emph{kernel}. Além disso, a ``versão básica'' do ataque
não necessita de acesso ao usuário
\textit{root}.~\cite{vanbulck2018foreshadow}.

Esse ataque consiste em trazer o dado do enclave para o \emph{cache L1}, passo
desnecessário se houver acesso ao usuário \textit{root}, depois, os dados
do enclave presentes na L1 são extraídos em uma execução especulativa, antes
que a CPU perceba que o processo não tem permissão para acessar tais dados e
cancele a operação.

As mitigações em microcódigo liberadas pela Intel são capazes de proteger
o processador contra o \textit{Foreshadow}, contudo há impacto na performance
de \textit{cloud computing}.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusão}

A conclusão do grupo foi que apesar de potenciais danos, a grande maioria dos
\textit{Side Channel Attacks} não representam significativa ameaça para a maior
parte dos usuários domésticos. Grandes empresas como a Intel e AMD precisam
urgentemente corrigir as falhas exploradas por SCA como a execução fora-de-ordem
e especulativa, pois muitos serviços grandes (principalmente serviços em nuvem)
estão vulneráveis a ataques.

Contudo, o usuário doméstico dificilmente seria alvo de ataques, pois eles são
muito difíceis de se executar e, em muitos casos, precisam de acesso físico à
máquina da vítima ou de informações que não são fáceis de serem obtidas.

Ainda assim, o estudo de \textit{Side Channel Attacks} é bastante relevante,
pois revela uma série de vulnerabilidades não óbvias que mecanismos possuem.
Ficou destacado o fato de que existem potencialmente centenas ou milhares de
formas de explorar tais vulnerabilidades, mas que um usuário comum não precisa
ficar alarmado com tal situação, pois ele dificilmente será alvo de um ataque
assim, dado que eles são extremamente individualizados e customizados para
atingir uma vítima em específico. Assim sendo, eles se tornam ou muito caros ou
muito trabalhosos e não valem a pena para grandes \textit{crackers} que procuram
vulnerabilidades facilmente exploráveis e com potencial de atigir várias vítimas
de uma só vez.

Portanto, apenas grandes empresas e governos devem tomar cuidados tão
específicos, pois eles sim podem ser alvos de SCAs. E as empresas criadoras de
peças de computador devem tomar um certo cuidado para não criar mecanismos
extremamente fáceis de serem explorados.

\newpage

\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
